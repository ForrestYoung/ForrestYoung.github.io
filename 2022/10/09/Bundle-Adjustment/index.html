<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Yulin">
    
    <title>
        
            Bundle Adjustment |
        
        Yulin&#39;s blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/favicon.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/favicon.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"学而不思则罔，思而不学则殆"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Yulin&#39;s blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Bundle Adjustment</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Yulin</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-10-09 17:00:00</span>
        <span class="mobile">2022-10-09 17:00</span>
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sba_motstr_l1norm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// memcpy</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cfloat&gt;</span>  <span class="comment">// DBL_MAX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;img_projs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;matrix/matrix.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;eigen3/Eigen/Dense&quot;</span>  <span class="comment">//  dense matrix</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;eigen3/Eigen/Sparse&quot;</span> <span class="comment">// sparse matrix</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;eigen3/Eigen/IterativeLinearSolvers&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sparse QR</span></span><br><span class="line"><span class="function">Eigen::VectorXd <span class="title">LinEqnsSolver</span><span class="params">(<span class="type">const</span> Eigen::SparseMatrix&lt;<span class="type">double</span>&gt; A, <span class="type">const</span> Eigen::VectorXd b)</span> </span>&#123;</span><br><span class="line">    Eigen::SparseQR&lt;Eigen::SparseMatrix&lt;<span class="type">double</span>&gt;, Eigen::AMDOrdering&lt;<span class="type">int</span>&gt; &gt; solver;</span><br><span class="line">    solver.<span class="built_in">compute</span>(A);</span><br><span class="line">    <span class="keyword">if</span> (solver.<span class="built_in">info</span>() != Eigen::Success) &#123;</span><br><span class="line">        <span class="comment">// decomposition failed</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> solver.<span class="built_in">solve</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcImgParallelProjJac</span><span class="params">(<span class="type">double</span> param[<span class="number">6</span>], <span class="type">double</span> M[<span class="number">3</span>], <span class="type">double</span> jacmP[<span class="number">2</span>][<span class="number">6</span>], <span class="type">double</span> jacmS[<span class="number">2</span>][<span class="number">3</span>])</span> <span class="comment">// Ref</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> s, alpha, beta, gamma, t0, t1;</span><br><span class="line">	<span class="type">double</span> X, Y, Z;</span><br><span class="line">	s = param[<span class="number">0</span>]; alpha = param[<span class="number">1</span>]; beta = param[<span class="number">2</span>]; gamma = param[<span class="number">3</span>]; t0 = param[<span class="number">4</span>]; t1 = param[<span class="number">5</span>];</span><br><span class="line">	X = M[<span class="number">0</span>]; Y = M[<span class="number">1</span>]; Z = M[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="type">double</span> cos_alpha = <span class="built_in">cos</span>(alpha);</span><br><span class="line">	<span class="type">double</span> sin_alpha = <span class="built_in">sin</span>(alpha);</span><br><span class="line">	<span class="type">double</span> cos_beta = <span class="built_in">cos</span>(beta);</span><br><span class="line">	<span class="type">double</span> sin_beta = <span class="built_in">sin</span>(beta);</span><br><span class="line">	<span class="type">double</span> cos_gamma = <span class="built_in">cos</span>(gamma);</span><br><span class="line">	<span class="type">double</span> sin_gamma = <span class="built_in">sin</span>(gamma);</span><br><span class="line">	<span class="type">double</span> s_s = <span class="number">1</span>/s;</span><br><span class="line">	jacmP[<span class="number">0</span>][<span class="number">0</span>] = (-cos_gamma*(cos_beta*X+sin_alpha*sin_beta*Y-cos_alpha*sin_beta*Z)+sin_gamma*(cos_alpha*Y+sin_alpha*Z))*s_s*s_s;</span><br><span class="line">	jacmP[<span class="number">0</span>][<span class="number">1</span>] = (cos_gamma*(cos_alpha*sin_beta*Y+sin_alpha*sin_beta*Z)-sin_gamma*(-sin_alpha*Y+cos_alpha*Z))*s_s;</span><br><span class="line">	jacmP[<span class="number">0</span>][<span class="number">2</span>] = cos_gamma*(-sin_beta*X+sin_alpha*cos_beta*Y-cos_alpha*cos_beta*Z)*s_s;</span><br><span class="line">	jacmP[<span class="number">0</span>][<span class="number">3</span>] = -sin_gamma*((cos_beta*X+sin_alpha*sin_beta*Y-cos_alpha*sin_beta*Z)*s_s-t0)-cos_gamma*((cos_alpha*Y+sin_alpha*Z)*s_s-t1);</span><br><span class="line">	jacmP[<span class="number">0</span>][<span class="number">4</span>] = -cos_gamma;</span><br><span class="line">	jacmP[<span class="number">0</span>][<span class="number">5</span>] = sin_gamma;</span><br><span class="line">	jacmP[<span class="number">1</span>][<span class="number">0</span>] = (-sin_gamma*(cos_beta*X+sin_alpha*sin_beta*Y-cos_alpha*sin_beta*Z)-cos_gamma*(cos_alpha*Y+sin_alpha*Z))*s_s*s_s;</span><br><span class="line">	jacmP[<span class="number">1</span>][<span class="number">1</span>] = (sin_gamma*(cos_alpha*sin_beta*Y+sin_alpha*sin_beta*Z)+cos_gamma*(-sin_alpha*Y+cos_alpha*Z))*s_s;</span><br><span class="line">	jacmP[<span class="number">1</span>][<span class="number">2</span>] = sin_gamma*(-sin_beta*X+sin_alpha*cos_beta*Y-cos_alpha*cos_beta*Z)*s_s;</span><br><span class="line">	jacmP[<span class="number">1</span>][<span class="number">3</span>] = cos_gamma*((cos_beta*X+sin_alpha*sin_beta*Y-cos_alpha*sin_beta*Z)*s_s-t0)-sin_gamma*((cos_alpha*Y+sin_alpha*Z)*s_s-t1);</span><br><span class="line">	jacmP[<span class="number">1</span>][<span class="number">4</span>] = -sin_gamma;</span><br><span class="line">	jacmP[<span class="number">1</span>][<span class="number">5</span>] = -cos_gamma;</span><br><span class="line">	</span><br><span class="line">	jacmS[<span class="number">0</span>][<span class="number">0</span>] = cos_gamma*cos_beta*s_s;</span><br><span class="line">	jacmS[<span class="number">0</span>][<span class="number">1</span>] = (cos_gamma*sin_alpha*sin_beta-sin_gamma*cos_alpha)*s_s;</span><br><span class="line">	jacmS[<span class="number">0</span>][<span class="number">2</span>] = (-cos_gamma*cos_alpha*sin_beta-sin_gamma*sin_alpha)*s_s;</span><br><span class="line">	jacmS[<span class="number">1</span>][<span class="number">0</span>] = sin_gamma*cos_beta*s_s;</span><br><span class="line">	jacmS[<span class="number">1</span>][<span class="number">1</span>] = (sin_gamma*sin_alpha*sin_beta+cos_gamma*cos_alpha)*s_s;</span><br><span class="line">	jacmS[<span class="number">1</span>][<span class="number">2</span>] = (-sin_gamma*cos_alpha*sin_beta+cos_gamma*sin_alpha)*s_s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JacMat</span><span class="params">(<span class="type">double</span> *parameter_P0, <span class="type">char</span> *vmask, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts, <span class="comment">/* return value */</span><span class="type">double</span> *sjacm)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> *images = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>];</span><br><span class="line">    <span class="type">double</span> *points = <span class="keyword">new</span> <span class="type">double</span>[n3Dpts*<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(images, parameter_P0, <span class="built_in">sizeof</span>(<span class="type">double</span>) * (ncams*<span class="number">6</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(points, parameter_P0 + ncams*<span class="number">6</span>, <span class="built_in">sizeof</span>(<span class="type">double</span>) * (n3Dpts*<span class="number">3</span>));</span><br><span class="line">    <span class="type">int</span> ncol = ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n3Dpts; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncams; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vmask[i*ncams+j]) &#123; <span class="comment">// ith 3D point is visible in jth camera</span></span><br><span class="line">                <span class="type">double</span> param[<span class="number">6</span>], M[<span class="number">3</span>];</span><br><span class="line">                <span class="built_in">memcpy</span>(param, images+<span class="number">6</span>*j, <span class="built_in">sizeof</span>(<span class="type">double</span>)*<span class="number">6</span>);</span><br><span class="line">                <span class="built_in">memcpy</span>(M,     points+<span class="number">3</span>*i, <span class="built_in">sizeof</span>(<span class="type">double</span>)*<span class="number">3</span>);</span><br><span class="line">                <span class="type">double</span> jacmP[<span class="number">2</span>][<span class="number">6</span>], jacmS[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">                <span class="comment">// **********************************There has a question*****************************************</span></span><br><span class="line">                <span class="comment">//                  calccalcImgParallelProjJac -&gt; calcImgParallelProjJac</span></span><br><span class="line">                <span class="built_in">calcImgParallelProjJac</span>(param, M, jacmP, jacmS);</span><br><span class="line">                <span class="comment">// ***********************************************************************************************</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; r++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">6</span>; c++) &#123;</span><br><span class="line">                        <span class="comment">// sjacm[(i*2*ncams+j*2 + r)][(j*6 + c)] = jacmP[r][c];</span></span><br><span class="line">                        sjacm[(i*<span class="number">2</span>*ncams+j*<span class="number">2</span> + r)*ncol+(j*<span class="number">6</span> + c)] = jacmP[r][c];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; r++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++) &#123;</span><br><span class="line">                        sjacm[(i*<span class="number">2</span>*ncams+j*<span class="number">2</span> + r)*ncol+(<span class="number">6</span>*ncams+i*<span class="number">3</span> + c)] = jacmS[r][c];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Eigen::VectorXd <span class="title">f</span><span class="params">(<span class="type">int</span> *p, <span class="type">char</span> *vmask, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> *images = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>];</span><br><span class="line">    <span class="type">double</span> *points = <span class="keyword">new</span> <span class="type">double</span>[n3Dpts*<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(images, p,              <span class="built_in">sizeof</span>(<span class="type">double</span>) * (ncams *<span class="number">6</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(points, p + (ncams *<span class="number">6</span>), <span class="built_in">sizeof</span>(<span class="type">double</span>) * (n3Dpts*<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; f;</span><br><span class="line">    <span class="type">double</span> param[<span class="number">6</span>], M[<span class="number">3</span>], n[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n3Dpts; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncams; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vmask[i*ncams+j]) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(param, images+<span class="number">6</span>*j, <span class="built_in">sizeof</span>(<span class="type">double</span>)*<span class="number">6</span>);</span><br><span class="line">                <span class="built_in">memcpy</span>(M,     points+<span class="number">3</span>*i, <span class="built_in">sizeof</span>(<span class="type">double</span>)*<span class="number">3</span>);</span><br><span class="line">                <span class="built_in">calcImgParallelProj</span>(param, M, n);</span><br><span class="line">                f.<span class="built_in">push_back</span>(n[<span class="number">0</span>]);</span><br><span class="line">                f.<span class="built_in">push_back</span>(n[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f.<span class="built_in">push_back</span>(<span class="number">0.0</span>);</span><br><span class="line">                f.<span class="built_in">push_back</span>(<span class="number">0.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_f</span><span class="params">(f.data(), f.size())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> vec_f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResErr</span><span class="params">(<span class="type">double</span> *p, <span class="type">double</span> *imgpts, <span class="type">char</span> *vmask, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts, <span class="type">double</span> *r)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> *images = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>];</span><br><span class="line">    <span class="type">double</span> *points = <span class="keyword">new</span> <span class="type">double</span>[n3Dpts*<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(images, p,              <span class="built_in">sizeof</span>(<span class="type">double</span>) * (ncams *<span class="number">6</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(points, p + (ncams *<span class="number">6</span>), <span class="built_in">sizeof</span>(<span class="type">double</span>) * (n3Dpts*<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> gap = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; f, u;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n3Dpts; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ncams; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vmask[i*ncams+j]) &#123;</span><br><span class="line">                <span class="type">double</span> param[<span class="number">6</span>], M[<span class="number">3</span>], n[<span class="number">2</span>];</span><br><span class="line">                <span class="built_in">memcpy</span>(param, images+<span class="number">6</span>*j, <span class="built_in">sizeof</span>(<span class="type">double</span>)*<span class="number">6</span>);</span><br><span class="line">                <span class="built_in">memcpy</span>(M,     points+<span class="number">3</span>*i, <span class="built_in">sizeof</span>(<span class="type">double</span>)*<span class="number">3</span>);</span><br><span class="line">                <span class="built_in">calcImgParallelProj</span>(param, M, n);</span><br><span class="line">                f.<span class="built_in">push_back</span>(n[<span class="number">0</span>]);</span><br><span class="line">                f.<span class="built_in">push_back</span>(n[<span class="number">1</span>]);</span><br><span class="line">                u.<span class="built_in">push_back</span>(imgpts[i*(ncams*<span class="number">2</span>)+<span class="number">2</span>*j + <span class="number">0</span> - gap*<span class="number">2</span>]);</span><br><span class="line">                u.<span class="built_in">push_back</span>(imgpts[i*(ncams*<span class="number">2</span>)+<span class="number">2</span>*j + <span class="number">1</span> - gap*<span class="number">2</span>]);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f.<span class="built_in">push_back</span>(<span class="number">0.0</span>);</span><br><span class="line">                f.<span class="built_in">push_back</span>(<span class="number">0.0</span>);</span><br><span class="line">                u.<span class="built_in">push_back</span>(<span class="number">0.0</span>);</span><br><span class="line">                u.<span class="built_in">push_back</span>(<span class="number">0.0</span>);</span><br><span class="line">                gap++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ncams*<span class="number">2</span>*n3Dpts; i++) r[i] = f[i]-u[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return (double *)c1,c2,d1,d2,d,g</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComputeC1C2D1D2</span><span class="params">(<span class="type">double</span> *jac, <span class="type">double</span> *r, <span class="type">double</span> *x, <span class="type">double</span> t, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">/* return value: */</span><span class="type">double</span> *c1, <span class="type">double</span> *c2, <span class="type">double</span> *d1, <span class="type">double</span> *d2, <span class="type">double</span> *d, <span class="type">double</span> *g)</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Map&lt;RMatrixXd&gt; <span class="title">mat_jac</span><span class="params">(jac, ncams*<span class="number">2</span>*n3Dpts, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)</span></span>;</span><br><span class="line">    Eigen::SparseMatrix&lt;<span class="type">double</span>&gt;  sp_jac = mat_jac.<span class="built_in">sparseView</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_r</span> <span class="params">(r, ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_x</span> <span class="params">(x, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    Eigen::VectorXd dp = vec_x.<span class="built_in">head</span>(ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>); </span><br><span class="line">    Eigen::VectorXd  s = vec_x.<span class="built_in">tail</span>(ncams*<span class="number">2</span>*n3Dpts); </span><br><span class="line">    Eigen::VectorXd jac_dp_r;</span><br><span class="line"></span><br><span class="line">    jac_dp_r = sp_jac*dp + vec_r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ncams*<span class="number">2</span>*n3Dpts; i++) &#123; </span><br><span class="line">        c1[i] = <span class="number">1.0</span> / (s[i] - jac_dp_r[i]);</span><br><span class="line">        c2[i] = <span class="number">1.0</span> / (s[i] + jac_dp_r[i]);</span><br><span class="line">        d1[i] = c1[i]*c1[i] + c2[i]*c2[i];</span><br><span class="line">        d2[i] = c2[i]*c2[i] - c1[i]*c1[i];</span><br><span class="line">  </span><br><span class="line">        d[i] = <span class="number">2.0</span>                       /(s[i]*s[i] + jac_dp_r[i]*jac_dp_r[i]);</span><br><span class="line">        g[i] = <span class="number">2.0</span>*jac_dp_r[i]*(s[i]*t<span class="number">-1</span>)/(s[i]*s[i] + jac_dp_r[i]*jac_dp_r[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the Newton step (double *)dx and decrement (double)lambda</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComputeNewtonStepAndDecrement</span><span class="params">(<span class="type">double</span> *jac, <span class="type">double</span> *r, <span class="type">double</span> *x, <span class="type">double</span> t, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts, <span class="type">double</span> *dx, <span class="type">double</span> &amp;lambda)</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Map&lt;RMatrixXd&gt; <span class="title">mat_jac</span><span class="params">(jac, ncams*<span class="number">2</span>*n3Dpts, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)</span></span>;</span><br><span class="line">    Eigen::SparseMatrix&lt;<span class="type">double</span>&gt;  sp_jac   = mat_jac.<span class="built_in">sparseView</span>();</span><br><span class="line">    Eigen::SparseMatrix&lt;<span class="type">double</span>&gt;  <span class="type">sp_jac_t</span> =  sp_jac.<span class="built_in">transpose</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> *arr_c1 = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line">    <span class="type">double</span> *arr_c2 = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line">    <span class="type">double</span> *arr_d1 = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line">    <span class="type">double</span> *arr_d2 = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line">    <span class="type">double</span> *arr_d  = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line">    <span class="type">double</span> *arr_g  = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> *arr_ddp = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>];</span><br><span class="line">    <span class="type">double</span> *arr_ds  = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_c1</span><span class="params">(arr_c1, ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_c2</span><span class="params">(arr_c2, ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_d1</span><span class="params">(arr_d1, ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_d2</span><span class="params">(arr_d2, ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_d</span> <span class="params">(arr_d,  ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_g</span> <span class="params">(arr_g,  ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_ddp</span><span class="params">(arr_ddp, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_ds</span> <span class="params">(arr_ds,  ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_dx</span> <span class="params">(    dx,  ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>;</span><br><span class="line">    <span class="function">Eigen::VectorXd            <span class="title">antigrad</span><span class="params">(         ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ComputeC1C2D1D2</span>(jac, r, x, t, ncams, n3Dpts, arr_c1, arr_c2, arr_d1, arr_d2, arr_d, arr_g);</span><br><span class="line"></span><br><span class="line">    Eigen::SparseMatrix&lt;<span class="type">double</span>&gt; sp_diag_d = Eigen::<span class="built_in">MatrixXd</span>(vec_d.<span class="built_in">asDiagonal</span>()).<span class="built_in">sparseView</span>();</span><br><span class="line">    Eigen::SparseMatrix&lt;<span class="type">double</span>&gt; sp_a1; </span><br><span class="line">    Eigen::VectorXd                b1, b2; </span><br><span class="line"></span><br><span class="line">    sp_a1 =  <span class="type">sp_jac_t</span> * sp_diag_d * sp_jac;</span><br><span class="line">       b1 = -<span class="type">sp_jac_t</span> * vec_g;</span><br><span class="line">    vec_ddp = <span class="built_in">LinEqnsSolver</span>(sp_a1, b1);</span><br><span class="line"></span><br><span class="line">    b2 = (-t)*Eigen::VectorXd::<span class="built_in">Ones</span>(ncams*<span class="number">2</span>*n3Dpts) + vec_c1 + vec_c2 </span><br><span class="line">       + (<span class="number">-1</span>)*Eigen::<span class="built_in">SparseMatrix</span>&lt;<span class="type">double</span>&gt;(Eigen::<span class="built_in">MatrixXd</span>(vec_d2.<span class="built_in">asDiagonal</span>()).<span class="built_in">sparseView</span>())*sp_jac*vec_ddp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ncams*<span class="number">2</span>*n3Dpts; i++) &#123;</span><br><span class="line">        vec_ds[i] = <span class="number">1.0</span>/vec_d1[i] * b2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vec_dx.<span class="built_in">head</span>(ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>) = vec_ddp;</span><br><span class="line">    vec_dx.<span class="built_in">tail</span>(ncams*<span class="number">2</span>*n3Dpts)   = vec_ds;</span><br><span class="line"></span><br><span class="line">    antigrad.<span class="built_in">head</span>(ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>) = -<span class="type">sp_jac_t</span>*(vec_c1-vec_c2);</span><br><span class="line">    antigrad.<span class="built_in">tail</span>(ncams*<span class="number">2</span>*n3Dpts)   = (-t)*Eigen::VectorXd::<span class="built_in">Ones</span>(ncams*<span class="number">2</span>*n3Dpts) + vec_c1 + vec_c2;</span><br><span class="line">    </span><br><span class="line">    lambda = antigrad.<span class="built_in">dot</span>(vec_dx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">LogBarrierFunc</span><span class="params">(<span class="type">double</span> *jac, <span class="type">double</span> *r, <span class="type">double</span> *x, <span class="type">double</span> t, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts)</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Map&lt;RMatrixXd&gt; <span class="title">mat_jac</span><span class="params">(jac, ncams*<span class="number">2</span>*n3Dpts, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)</span></span>;</span><br><span class="line">    Eigen::SparseMatrix&lt;<span class="type">double</span>&gt;  sp_jac = mat_jac.<span class="built_in">sparseView</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_r</span> <span class="params">(r,                    ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_x</span> <span class="params">(x, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line"></span><br><span class="line">    Eigen::VectorXd dp = vec_x.<span class="built_in">head</span>(ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>); </span><br><span class="line">    Eigen::VectorXd  s = vec_x.<span class="built_in">tail</span>(ncams*<span class="number">2</span>*n3Dpts); </span><br><span class="line">    </span><br><span class="line">    Eigen::VectorXd jac_dp;</span><br><span class="line">    <span class="function">Eigen::VectorXd <span class="title">Ax</span><span class="params">(<span class="number">2</span>*(ncams*<span class="number">2</span>*n3Dpts))</span></span>;</span><br><span class="line">    <span class="function">Eigen::VectorXd <span class="title">b</span> <span class="params">(<span class="number">2</span>*(ncams*<span class="number">2</span>*n3Dpts))</span></span>;</span><br><span class="line"></span><br><span class="line">    jac_dp = sp_jac*dp;</span><br><span class="line">    Ax.<span class="built_in">head</span>(ncams*<span class="number">2</span>*n3Dpts) =  jac_dp - s;</span><br><span class="line">    Ax.<span class="built_in">tail</span>(ncams*<span class="number">2</span>*n3Dpts) = -jac_dp - s;</span><br><span class="line"></span><br><span class="line">    b. <span class="built_in">head</span>(ncams*<span class="number">2</span>*n3Dpts) = -vec_r;</span><br><span class="line">    b. <span class="built_in">tail</span>(ncams*<span class="number">2</span>*n3Dpts) =  vec_r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> phi = t * s.<span class="built_in">sum</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*(ncams*<span class="number">2</span>*n3Dpts); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i]-Ax[i] &lt;= <span class="number">0</span>) <span class="keyword">return</span> DBL_MAX;</span><br><span class="line">        phi -= <span class="built_in">log</span>(b[i]-Ax[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> phi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">BLSCond</span><span class="params">(<span class="type">double</span> *jac, <span class="type">double</span> *r, <span class="type">double</span> *x, <span class="type">double</span> *dx, <span class="type">double</span> alpha, <span class="type">double</span> step, <span class="type">double</span> t, <span class="type">double</span> lambda, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> *nx = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts]; <span class="comment">// nx = x+step*dx</span></span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_x</span> <span class="params">(x,  ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_dx</span><span class="params">(dx, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_xn</span><span class="params">(nx, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    vec_xn = vec_x + step*vec_dx;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogBarrierFunc</span>(jac, r, nx, t, ncams, n3Dpts) &gt; <span class="built_in">LogBarrierFunc</span>(jac, r, x, t, ncams, n3Dpts) - alpha*step*lambda;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">BackLineSearch</span><span class="params">(<span class="type">double</span> *jac, <span class="type">double</span> *r, <span class="type">double</span> *x, <span class="type">double</span> *dx, <span class="type">double</span> t, <span class="type">double</span> lambda, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> alpha = <span class="number">0.01</span>, beta = <span class="number">0.5</span>, step = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BLSCond</span>(jac, r, x, dx, alpha, step, t, lambda, ncams, n3Dpts)) step *= beta;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return (double *)x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NewtonsMethod</span><span class="params">(<span class="type">double</span> *jac, <span class="type">double</span> *r, <span class="type">double</span> *x, <span class="type">double</span> t, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> *dx = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts], lambda;</span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_x</span> <span class="params">(x,  ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_dx</span><span class="params">(dx, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="type">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> last = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">ComputeNewtonStepAndDecrement</span>(jac, r, x, t, ncams, n3Dpts, dx, lambda);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(lambda/<span class="number">2.0</span> - last) &lt; <span class="number">0.1</span>*eps) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Newton&#x27;s method failed!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lambda/<span class="number">2.0</span> &lt; eps) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">double</span> step = <span class="built_in">BackLineSearch</span>(jac, r, x, dx, t, lambda, ncams, n3Dpts);</span><br><span class="line">        vec_x += step * vec_dx;</span><br><span class="line">  </span><br><span class="line">        last = lambda/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return (double *)x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BarrierMethod</span><span class="params">(<span class="type">double</span> *jac, <span class="type">double</span> *r, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts, <span class="type">double</span> *x)</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_r</span> <span class="params">(r, ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_x</span> <span class="params">(x, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line"></span><br><span class="line">    vec_x.<span class="built_in">head</span>(ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>) =                    Eigen::VectorXd::<span class="built_in">Zero</span>(ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>);</span><br><span class="line">    vec_x.<span class="built_in">tail</span>(ncams*<span class="number">2</span>*n3Dpts)   = vec_r.<span class="built_in">cwiseAbs</span>() + Eigen::VectorXd::<span class="built_in">Ones</span>(ncams*<span class="number">2</span>*n3Dpts);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> m = <span class="number">2.0</span>*(ncams*<span class="number">2</span>*n3Dpts), t = m/vec_x.<span class="built_in">tail</span>(ncams*<span class="number">2</span>*n3Dpts).<span class="built_in">sum</span>(), miu = <span class="number">10.0</span>, eps = <span class="number">1e-5</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">NewtonsMethod</span>(jac, r, x, t, ncams, n3Dpts);</span><br><span class="line">        <span class="keyword">if</span> (m/t &lt; eps) <span class="keyword">break</span>;</span><br><span class="line">        t *= miu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input p, u(calc in imgpts), eta, lambda</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sba_motstr_l1norm</span><span class="params">(<span class="type">double</span> *p, <span class="type">double</span> *imgpts, <span class="type">char</span> *vmask, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> *jac = <span class="keyword">new</span> <span class="type">double</span>[(ncams*<span class="number">2</span>*n3Dpts) * (ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> *r   = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line">    <span class="type">double</span> *rk  = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> *dp  = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>];</span><br><span class="line">    <span class="type">double</span> *np  = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>]; <span class="comment">// stand for &quot;next p&quot;, aka np = p+dp</span></span><br><span class="line">    <span class="type">double</span> * x  = <span class="keyword">new</span> <span class="type">double</span>[ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts];</span><br><span class="line">    </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_r</span>  <span class="params">(r,  ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_rk</span> <span class="params">(rk, ncams*<span class="number">2</span>*n3Dpts)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_p</span>  <span class="params">(p,  ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)</span></span>; </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_dp</span> <span class="params">(dp, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)</span></span>;      </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_np</span> <span class="params">(np, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)</span></span>;      </span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXd&gt; <span class="title">vec_x</span>  <span class="params">(x,  ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span> + ncams*<span class="number">2</span>*n3Dpts)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::Map&lt;RMatrixXd&gt;       <span class="title">mat_jac</span><span class="params">(jac, ncams*<span class="number">2</span>*n3Dpts, ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ResErr</span>(p, imgpts, vmask, ncams, n3Dpts, rk); <span class="comment">// rk=r0 for k=0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> eta = <span class="number">1e-6</span>, lambda = <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">char</span> converge_sgn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (converge_sgn != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">JacMat</span>(p, vmask, ncams, n3Dpts, jac);     <span class="comment">// Get Jacobian matrix at p</span></span><br><span class="line">        <span class="built_in">BarrierMethod</span>(jac, r, ncams, n3Dpts, x);  <span class="comment">// Get x = [dp, s]</span></span><br><span class="line">        vec_dp = vec_x.<span class="built_in">head</span>(ncams*<span class="number">6</span>+n3Dpts*<span class="number">3</span>);</span><br><span class="line">        vec_np = vec_p + vec_dp;</span><br><span class="line">        <span class="built_in">ResErr</span>(np, imgpts, vmask, ncams, n3Dpts, r);</span><br><span class="line">        <span class="keyword">while</span> (vec_r.<span class="built_in">lpNorm</span>&lt;<span class="number">1</span>&gt;() &gt;= vec_rk.<span class="built_in">lpNorm</span>&lt;<span class="number">1</span>&gt;()) &#123;</span><br><span class="line">            vec_dp /= lambda;</span><br><span class="line">            <span class="keyword">if</span> (vec_dp.<span class="built_in">lpNorm</span>&lt;<span class="number">1</span>&gt;() &lt; eta) &#123;</span><br><span class="line">                converge_sgn = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// puts(&quot;converge!&quot;);</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec_np = vec_p + vec_dp;</span><br><span class="line">            <span class="built_in">ResErr</span>(np, imgpts, vmask, ncams, n3Dpts, r);</span><br><span class="line">        &#125;</span><br><span class="line">        p = np;</span><br><span class="line">        rk = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunL1</span><span class="params">(<span class="type">double</span> *motstr, <span class="type">double</span> *imgpts, <span class="type">char</span> *vmask, <span class="type">int</span> ncams, <span class="type">int</span> n3Dpts)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* motstr  ==  parameter_init_P0  in python code</span></span><br><span class="line"><span class="comment">       imgpts  ==  list_m             in python code */</span></span><br><span class="line">    <span class="comment">// **********************************TEST***********************************************</span></span><br><span class="line">    <span class="comment">// **********************************DONE***********************************************</span></span><br><span class="line">    <span class="built_in">sba_motstr_l1norm</span>(motstr, imgpts, vmask, ncams, n3Dpts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/11/07/LAPACK/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LAPACK</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/09/14/Problems/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Study and think</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Yulin</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
</div>



</body>
</html>
